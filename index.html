<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Document</title>
    <script>
        //***************** MODULES *****************//
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius, config = {}) {
            this.save();
            this.beginPath();
            this.moveTo(x + radius, y);
            this.lineTo(x + width - radius, y);
            this.quadraticCurveTo(x + width, y, x + width, y + radius);
            this.lineTo(x + width, y + height - radius);
            this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            this.lineTo(x + radius, y + height);
            this.quadraticCurveTo(x, y + height, x, y + height - radius);
            this.lineTo(x, y + radius);
            this.quadraticCurveTo(x, y, x + radius, y);
            this.closePath();
            this.fillStyle = config.background || "#000";
            this.strokeStyle = config.border || "#000";

            this.stroke();
            if (config.shadow) {
                this.shadowColor = config.shadow[4];
                this.shadowBlur = config.shadow[2];
                this.shadowOffsetX = config.shadow[0];
                this.shadowOffsetY = config.shadow[1];
            }
            this.fill();
            this.restore();
        }
        CanvasRenderingContext2D.prototype.autoPosition = function (x, y, width, height, margin = 8) {
            var translateX = 0;
            var translateY = 0;
            if (x + width + margin > this.canvas.offsetWidth) {
                translateX = x - (((x - width - margin) > this.canvas.offsetWidth - width - margin ? this.canvas.offsetWidth : x) - width - margin);
            }
            if (x - margin < 0) {
                translateX = x - margin;
            }
            if (y + height + margin > this.canvas.offsetHeight) {
                translateY = y - (((y - height - margin) > this.canvas.offsetHeight - height - margin ? this.canvas.offsetHeight : y) - height - margin);
            }
            if (y - margin < 0) {
                translateY = y - margin;
            }
            this.translate(-translateX, -translateY);
        }
        CanvasRenderingContext2D.prototype.textBlock = function (text, x, y, padding, radius, config = {}) {
            this.save();
            this.beginPath();
            this.font = `${config.fontSize}px ${config.fontFamily}`;
            this.textBaseline = 'middle';
            const textMetrics = this.measureText(text);
            const width = textMetrics.width;
            const height = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent;
            const rectSize = {
                width: width + padding.left + padding.right,
                height: height + padding.top + padding.bottom
            }
            if (config.align == 'center') {
                this.autoPosition(x - rectSize.width / 2, y, rectSize.width, rectSize.height);
                this.roundRect(x - rectSize.width / 2, y, rectSize.width, rectSize.height, radius, config);
                this.textAlign = 'center';
                this.fillText(text, x, y + (height + padding.top + padding.bottom) / 2);
            } else if (config.align == 'right') {
                this.autoPosition(x - rectSize.width, y, rectSize.width, rectSize.height);
                this.roundRect(x - rectSize.width, y, rectSize.width, rectSize.height, radius, config);
                this.fillText(text, x - rectSize.width + padding.left, y + (height + padding.top + padding.bottom) / 2);
            } else {
                this.autoPosition(x, y, rectSize.width, rectSize.height);
                this.roundRect(x, y, width + padding.left + padding.right, height + padding.top + padding.bottom, radius, config);
                this.fillText(text, x + padding.left, y + (height + padding.top + padding.bottom) / 2);
            }
            this.restore();
        }

        function parseEasingFunction(easing) {
            const easingFunctions = {
                ease: t => t * t * (3 - 2 * t),
                'ease-in': t => t * t,
                'ease-out': t => 1 - (1 - t) * (1 - t),
                'ease-in-out': t => t < 0.5 ? 2 * t * t : 1 - 2 * (1 - t) * (1 - t),
                'tep-start': t => 0,
                'tep-end': t => t >= 1 ? 1 : 0,
                linear: function (x) {
                    return x;
                },
                easeInQuad: function (x) {
                    return x * x;
                },
                easeOutQuad: function (x) {
                    return 1 - (1 - x) * (1 - x);
                },
                easeInOutQuad: function (x) {
                    return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
                },
                easeInCubic: function (x) {
                    return x * x * x;
                },
                easeOutCubic: function (x) {
                    return 1 - Math.pow(1 - x, 3);
                },
                easeInOutCubic: function (x) {
                    return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
                },
                easeInQuart: function (x) {
                    return x * x * x * x;
                },
                easeOutQuart: function (x) {
                    return 1 - Math.pow(1 - x, 4);
                },
                easeInOutQuart: function (x) {
                    return x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2;
                },
                easeInQuint: function (x) {
                    return x * x * x * x * x;
                },
                easeOutQuint: function (x) {
                    return 1 - Math.pow(1 - x, 5);
                },
                easeInOutQuint: function (x) {
                    return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;
                },
                easeInSine: function (x) {
                    return 1 - Math.cos((x * Math.PI) / 2);
                },
                easeOutSine: function (x) {
                    return Math.sin((x * Math.PI) / 2);
                },
                easeInOutSine: function (x) {
                    return -(Math.cos(Math.PI * x) - 1) / 2;
                },
                easeInExpo: function (x) {
                    return x === 0 ? 0 : Math.pow(2, 10 * x - 10);
                },
                easeOutExpo: function (x) {
                    return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);
                },
                easeInOutExpo: function (x) {
                    return x === 0
                        ? 0
                        : x === 1
                            ? 1
                            : x < 0.5
                                ? Math.pow(2, 20 * x - 10) / 2
                                : (2 - Math.pow(2, -20 * x + 10)) / 2;
                },
                easeInCirc: function (x) {
                    return 1 - Math.sqrt(1 - Math.pow(x, 2));
                },
                easeOutCirc: function (x) {
                    return Math.sqrt(1 - Math.pow(x - 1, 2));
                },
                easeInOutCirc: function (x) {
                    return x < 0.5
                        ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2
                        : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2;
                },
                easeInBack: function (x) {
                    const c1 = 1.70158;
                    const c2 = c1 * 1.525;
                    const c3 = c1 + 1;
                    return c3 * x * x * x - c1 * x * x;
                },
                easeOutBack: function (x) {
                    const c1 = 1.70158;
                    const c2 = c1 * 1.525;
                    const c3 = c1 + 1;
                    return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
                },
                easeInOutBack: function (x) {
                    const c1 = 1.70158;
                    const c2 = c1 * 1.525;
                    const c3 = c1 + 1;
                    return x < 0.5
                        ? (Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2
                        : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;
                },
                easeInElastic: function (x) {
                    return x === 0
                        ? 0
                        : x === 1
                            ? 1
                            : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * Math.PI / 3);
                },
                easeOutElastic: function (x) {
                    return x === 0
                        ? 0
                        : x === 1
                            ? 1
                            : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * Math.PI / 3) + 1;
                },
                easeInOutElastic: function (x) {
                    return x === 0
                        ? 0
                        : x === 1
                            ? 1
                            : x < 0.5
                                ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * Math.PI / 4.5)) / 2
                                : (Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * Math.PI / 4.5)) / 2 + 1;
                },
                easeInBounce: function (x) {
                    return 1 - easingFunctions.easeOutBounce(1 - x);
                },
                easeOutBounce: function (x) {
                    const n1 = 7.5625;
                    const d1 = 2.75;

                    if (x < 1 / d1) {
                        return n1 * x * x;
                    } else if (x < 2 / d1) {
                        return n1 * (x -= 1.5 / d1) * x + 0.75;
                    } else if (x < 2.5 / d1) {
                        return n1 * (x -= 2.25 / d1) * x + 0.9375;
                    } else {
                        return n1 * (x -= 2.625 / d1) * x + 0.984375;
                    }
                },
                easeInOutBounce: function (x) {
                    return x < 0.5
                        ? (1 - easingFunctions.easeOutBounce(1 - 2 * x)) / 2
                        : (1 + easingFunctions.easeOutBounce(2 * x - 1)) / 2;
                }
            };

            if (easing == false) {
                return Object.keys(easingFunctions);
            }

            if (easing in easingFunctions) {
                return easingFunctions[easing];
            }

            if (easing.startsWith('cubic-bezier(')) {
                const bezierParams = easing.match(/cubic-bezier\(([^)]+)\)/)[1].split(',').map(Number);
                if (bezierParams.length !== 4) {
                    throw new Error(`Invalid cubic-bezier parameters: ${easing}`);
                }
                const [x1, y1, x2, y2] = bezierParams;
                return t => {
                    const t2 = t * t;
                    const t3 = t2 * t;
                    return (1 - 3 * x2 + 3 * x1) * t3 + (3 * x2 - 6 * x1) * t2 + (3 * x1) * t;
                };
            }

            if (easing.startsWith('steps(')) {
                const stepsParams = easing.match(/steps\(([^)]+)\)/)[1].split(',').map(Number);
                if (stepsParams.length < 2) {
                    throw new Error(`Invalid steps parameters: ${easing}`);
                }
                const [n, startOrEnd] = stepsParams;
                return t => {
                    const step = Math.floor(t * n);
                    return startOrEnd === 1 ? step / n : (step + 1) / n;
                };
            }

            if (easing.startsWith('frames(')) {
                const framesParams = easing.match(/frames\(([^)]+)\)/)[1].split(',').map(Number);
                if (framesParams.length < 1) {
                    throw new Error(`Invalid frames parameters: ${easing}`);
                }
                const n = framesParams[0];
                return t => {
                    const frame = Math.floor(t * n);
                    return frame / n;
                };
            }

            console.warn(`Unsupported easing function: ${easing}`);

            return t => t;
        }

        function getAnimateData(keyframes, name, time, duration, easing) {
            const percent = (time % duration) / duration * 100;
            var start = 0;
            var end = 0;
            Object.keys(keyframes).forEach((keyframe, i) => {
                if (Object.keys(keyframes).length > i + 1) {
                    if (keyframe <= percent && percent <= Object.keys(keyframes)[i + 1]) {
                        start = +keyframe;
                        end = +Object.keys(keyframes)[i + 1];
                    }
                }
            })
            if (!keyframes[start].hasOwnProperty(name) && !keyframes[end].hasOwnProperty) {
                return 0;
            } else {
                return keyframes[start][name] + (keyframes[end][name] - keyframes[start][name]) * (percent - start) / (end - start);
            }
        }
    </script>
    <style>
        .tip {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 3420px;
            max-width: min(420px, 80%);
            padding: .5rem .75rem .875rem 1.125rem;
            box-sizing: border-box;
            border-radius: .375rem;
            background: rgb(246 248 255);
            user-select: none;
            -webkit-user-select: none;
            box-shadow: 0 4px 16px 4px rgba(0, 0, 0, 0.050);
        }

        .item {
            display: flex;
            gap: .5rem;
            align-items: center;
            padding: .375rem .75rem;
            justify-content: space-between;
            width: -webkit-fill-available;
        }

        .key {
            background: rgb(220 233 255);
            border-radius: .375rem;
            padding: 6px 12px;
            white-space: nowrap;
        }

        .keys {
            display: flex;
            gap: .375rem;
            white-space: nowrap;
        }

        .action {
            overflow: hidden;
            white-space: nowrap;
        }

        .tip-container {
            position: fixed;
            top: 2rem;
            width: 100vw;
            display: flex;
            justify-content: center;
            z-index: 9;
        }

        .title {
            display: flex;
            gap: .5rem;
            align-items: center;
            padding: .5rem .75rem .75rem;
            justify-content: space-between;
            width: -webkit-fill-available;
        }

        .text {
            font-weight: 600;
            font-size: 125%;
        }

        .close {
            color: rgb(177 177 177);
            cursor: pointer;
            width: 20px;
            height: 20px;
            min-width: 20px;
            min-height: 20px;
        }
    </style>
</head>

<body style="width: 100vw; height: 100vh; margin: 0; overflow: hidden;">
    <span class="tip-container" tag="tip">
        <span class="tip">
            <div class="title">
                <div class="text">Usage</div>
                <div class="close" onclick="document.querySelector('.tip').remove();">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M18 6 6 18" />
                        <path d="m6 6 12 12" />
                    </svg>
                </div>
            </div>
            <div class="item">
                <div class="action">Move viewport / Move point</div>
                <div class="keys">
                    <div class="key">Drag</div>
                </div>
            </div>
            <div class="item">
                <div class="action">Select point ( Unavailable )</div>
                <div class="keys">
                    <div class="key">Ctrl</div>
                    <div class="key">Drag</div>
                </div>
            </div>
            <div class="item">
                <div class="action">Add point</div>
                <div class="keys">
                    <div class="key">Right Click</div>
                </div>
            </div>
            <div class="item">
                <div class="action">Scale viewport</div>
                <div class="keys">
                    <div class="key">Ctrl</div>
                    <div class="key">Wheel</div>
                </div>
            </div>
        </span>
    </span>
    <canvas id="canvas" style="width: 100vw; height: 100vh; position: fixed; left: 0; top: 0;"></canvas>

    <script>
        function canvasClarifier(canvas, ctx, width, height) {
            const originalSize = {
                width: (width ? width : canvas.offsetWidth),
                height: (height ? height : canvas.offsetHeight)
            }
            var ratio = window.devicePixelRatio || 1;
            canvas.width = originalSize.width * ratio;
            canvas.height = originalSize.height * ratio;
            ctx.scale(ratio, ratio);
            ctxScale = ratio;
            if (originalSize.width != canvas.offsetWidth || originalSize.height != canvas.offsetHeight) {
                canvas.style.width = originalSize.width + 'px';
                canvas.style.height = originalSize.height + 'px';
            }
        }

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const defaultSize = 6;
        const defaultDiffusion = 3;
        const defaultLineWidth = 1;

        canvasClarifier(canvas, ctx);

        var size = 6;
        var diffusion = 3;
        var points = [];
        var originalPoints = points;
        var mousePosition = [0, 0];
        var mouseDown = false;
        var selecting = false;
        var moving = false;
        var selectRange = {
            x: [0, 0],
            y: [0, 0]
        }
        var hoveredPath = -1;
        var ctxScale = 1;
        var selected = [];
        var offset = 0;
        var viewport = {
            x: {
                from: 0,
                to: getCtxSize(ctx).width
            },
            y: {
                from: 0,
                to: getCtxSize(ctx).height
            }
        }

        var currentGap = 15;
        var gridMinGap = 10;
        var gridMaxGap = 20;

        var ranges = [1, 2, 5];
        var viewportScale = 1;

        function randomPoints(count = 12) {
            for (var i = 0; i < count; i++) {
                originalPoints.push(Math.floor(Math.random() * canvas.offsetWidth));
                originalPoints.push(Math.floor(Math.random() * canvas.offsetHeight));
            }
        }

        randomPoints();

        function getPosition(element, mode = 'absolute') {
            function offset(el) {
                var rect = el.getBoundingClientRect(),
                    scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,
                    scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                return { top: rect.top + scrollTop, left: rect.left + scrollLeft }
            }
            if (mode == 'fixed') {
                return { x: offset(element).left - scrollX, y: offset(element).top - scrollY };
            }
            return { x: offset(element).left, y: offset(element).top };
        }

        function toCanvasPosition(x, y, config = {
            mouse: false,
            mode: 'int',
            fixed: 0,
            convert: true
        }) {
            var canvasPosition = getPosition(canvas);
            if (config.mouse == true) {
                x = x - getPosition(canvas).x;
                y = y - getPosition(canvas).y;
            }
            var result = {
                x: (x - viewport.x.from) / viewportScale,
                y: (y - viewport.y.from) / viewportScale
            }
            if (config.convert == false) {
                result = {
                    x: (x - viewport.x.from),
                    y: (y - viewport.y.from)
                }
            }
            if (config.mode == 'original') {
                return result
            } else if (config.mode == 'fixed') {
                return {
                    x: Number(result.x.toFixed(fixed)),
                    y: Number(result.y.toFixed(fixed))
                }
            } else {
                return {
                    x: Math.floor(result.x),
                    y: Math.floor(result.y)
                }
            }
        }

        function inRange(value, start, end, mode = 'both') {
            // mode: controls whether to include start and end
            if (mode == 'start') {
                return value >= start && value < end;
            } else if (mode == 'end') {
                return value > start && value <= end;
            } else if (mode == 'none') {
                return value > start && value < end;
            } else {
                return value >= start && value <= end;
            }
        }

        function getGridUint() {
            var minCount = {
                x: Math.floor((viewport.x.to - viewport.x.from) / gridMaxGap),
                y: Math.floor((viewport.y.to - viewport.y.from) / gridMaxGap)
            }
            var maxCount = {
                x: Math.floor((viewport.x.to - viewport.x.from) / gridMinGap),
                y: Math.floor((viewport.y.to - viewport.y.from) / gridMinGap)
            }
            return { minCount, maxCount };
        }

        function getAbsolutePosition(x, y) {
            return {
                x: (x - viewport.x.from) * viewportScale,
                y: (y - viewport.y.from) * viewportScale
            }
        }

        function drawGrid() {
            ctx.save();
            ctx.beginPath();
            // ------- Draw Axis ------- //
            if (inRange(0, viewport.y.from, viewport.y.to)) {
                // X Axis
                var startPosition = getAbsolutePosition(viewport.x.from, 0);
                var endPosition = getAbsolutePosition(viewport.x.to, 0);
                ctx.beginPath();
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = '#000';
                ctx.moveTo(startPosition.x, startPosition.y);
                ctx.lineTo(endPosition.x, endPosition.y);
                ctx.stroke();
                ctx.closePath();
            }
            if (inRange(0, viewport.x.from, viewport.x.to)) {
                // Y Axis
                var startPosition = getAbsolutePosition(0, viewport.y.from);
                var endPosition = getAbsolutePosition(0, viewport.y.to);
                ctx.beginPath();
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = '#000';
                ctx.moveTo(startPosition.x, startPosition.y);
                ctx.lineTo(endPosition.x, endPosition.y);
                ctx.stroke();
                ctx.closePath();
            }

            ctx.restore();
        }

        function getCtxScale(ctx) {
            const transform = ctx.currentTransform;
            return {
                x: transform.a,
                y: transform.d
            }
        }

        function getCtxSize(ctx) {
            return {
                width: ctx.canvas.width / ctxScale,
                height: ctx.canvas.height / ctxScale
            };
        }

        function getPath(index, diffusion = 0) {
            var path = new Path2D();
            path.arc(points[0 + index * 2], points[1 + index * 2], size + diffusion * 2, 0, Math.PI * 2);
            return path;
        }

        function fillPath(index) {
            ctx.save();
            if (index == hoveredPath || selected.includes(index)) {
                ctx.fillStyle = 'rgba(26, 115, 232, .2)';
                ctx.fill(getPath(index, diffusion));
                ctx.fillStyle = 'rgb(26, 115, 232)';
                if (selected.includes(index)) {
                    ctx.strokeStyle = 'rgba(26, 115, 232)';
                    ctx.stroke(getPath(index, diffusion));
                } else {
                    ctx.beginPath();
                    ctx.save();
                    ctx.font = `${14 * viewportScale}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif`;
                    ctx.fillStyle = 'rgb(6 72 160)';
                    ctx.textBlock(`(${Math.floor(originalPoints[0 + index * 2])}, ${Math.floor(originalPoints[1 + index * 2])})`, points[0 + index * 2], points[1 + index * 2] + 16 * viewportScale, {
                        left: 8,
                        right: 8,
                        top: 6,
                        bottom: 6
                    }, 6, {
                        fontSize: 14,
                        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif',
                        background: '#dbe3f8',
                        border: '#dbe3f8',
                        align: 'center'
                    });
                    ctx.restore();
                    ctx.closePath();
                }
            }
            ctx.fill(getPath(index));
            ctx.restore();
        }

        function inWhichPath(x, y) {
            for (let i = 0; i < points.length; i++) {
                if (ctx.isPointInPath(getPath(i, diffusion), x * ctxScale, y * ctxScale) == true) {
                    return i;
                }
            }
            return -1;
        }

        function drawCurvedPath(cps, points) {
            var len = points.length / 2; // number of points
            if (len < 2) return;
            if (len == 2) {
                ctx.beginPath();
                ctx.moveTo(points[0], points[1]);
                ctx.lineTo(points[2], points[3]);
                ctx.stroke();
            }
            else {
                ctx.beginPath();
                ctx.moveTo(points[0], points[1]);
                // from point 0 to point 1 is a quadratic
                ctx.quadraticCurveTo(cps[0], cps[1], points[2], points[3]);
                // for all middle points, connect with bezier
                for (var i = 2; i < len - 1; i += 1) {
                    // console.log("to", points[2*i], points[2*i+1]);
                    ctx.bezierCurveTo(
                        cps[(2 * (i - 1) - 1) * 2], cps[(2 * (i - 1) - 1) * 2 + 1],
                        cps[(2 * (i - 1)) * 2], cps[(2 * (i - 1)) * 2 + 1],
                        points[i * 2], points[i * 2 + 1]);
                }
                ctx.quadraticCurveTo(
                    cps[(2 * (i - 1) - 1) * 2], cps[(2 * (i - 1) - 1) * 2 + 1],
                    points[i * 2], points[i * 2 + 1]);
                ctx.stroke();
            }
        }

        function drawControlPoints(cps) {
            for (var i = 0; i < cps.length; i += 4) {
                showPt(cps[i], cps[i + 1], "pink");
                showPt(cps[i + 2], cps[i + 3], "pink");
                drawLine(cps[i], cps[i + 1], cps[i + 2], cps[i + 3], "pink");
            }
        }

        function drawPoints(points) {
            for (var i = 0; i < points.length; i += 2) {
                showPt(points[i], points[i + 1], "black");
            }
        }

        function showPt(x, y, fillStyle) {
            ctx.save();
            ctx.beginPath();
            if (fillStyle) {
                ctx.fillStyle = fillStyle;
            }
            ctx.arc(x, y, 5 * viewportScale, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        }

        function drawLine(x1, y1, x2, y2, strokeStyle) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineWidth = 1 * viewportScale;
            if (strokeStyle) {
                ctx.save();
                ctx.strokeStyle = strokeStyle;
                ctx.stroke();
                ctx.restore();
            }
            else {
                ctx.save();
                ctx.strokeStyle = "pink";
                ctx.stroke();
                ctx.restore();
            }
        }

        function setCanvasStyle(attr, value) {
            if (window.getComputedStyle(canvas).getPropertyValue(attr) !== value) {
                canvas.style.setProperty(attr, value);
            }
        }

        var scaleInfoStatus = 'default';
        var scaleInfoTransitionDuration = 300;
        var scaleInfoVisibleTime = 1000;
        var scaleInfoTransitionStartTime = Date.now();
        var showScaleInfoCount = 0;
        var showScaleInfo = false;
        var showScaleInfoKeyframes = {
            0: {
                translateY: 2.5
            },
            80: {
                translateY: 0.4
            },
            90: {
                translateY: 0.1
            },
            100: {
                translateY: 0
            }
        }
        var hideScaleInfoKeyframes = {
            0: {
                translateY: 0
            },
            10: {
                translateY: 0.1
            },
            20: {
                translateY: 0.4
            },
            100: {
                translateY: 2.5
            }
        }

        function animate() {
            canvasClarifier(canvas, ctx);

            /*
            viewport = {
                x: {
                    from: 0,
                    to: getCtxSize(ctx).width
                },
                y: {
                    from: 0,
                    to: getCtxSize(ctx).height
                }
            }
            */

            ctx.beginPath();
            ctx.setLineDash([]);
            ctx.strokeStyle = '#000';

            points = [...originalPoints];
            points.forEach((point, i) => {
                points[i] = point * viewportScale - (i % 2 == 0 ? viewport.x.from : viewport.y.from);
            });

            function dista(arr, i, j) {
                return Math.sqrt(Math.pow(arr[2 * i] - arr[2 * j], 2) + Math.pow(arr[2 * i + 1] - arr[2 * j + 1], 2));
            }

            // return vector from i to j where i and j are indexes pointing into an array of points.
            function va(arr, i, j) {
                return [arr[2 * j] - arr[2 * i], arr[2 * j + 1] - arr[2 * i + 1]]
            }

            function ctlpoints(x1, y1, x2, y2, x3, y3) {
                var t = 0.5
                var v = va(arguments, 0, 2);
                var d01 = dista(arguments, 0, 1);
                var d12 = dista(arguments, 1, 2);
                var d012 = d01 + d12;
                return [x2 - v[0] * t * d01 / d012, y2 - v[1] * t * d01 / d012,
                x2 + v[0] * t * d12 / d012, y2 + v[1] * t * d12 / d012];
            }

            var cps = []; // There will be two control points for each "middle" point, 1 ... len-2e
            for (var i = 0; i < points.length - 2; i += 1) {
                cps = cps.concat(ctlpoints(points[2 * i], points[2 * i + 1],
                    points[2 * i + 2], points[2 * i + 3],
                    points[2 * i + 4], points[2 * i + 5]));
            }

            // drawGrid();

            drawControlPoints(cps);
            drawPoints(points);

            ctx.lineWidth = defaultLineWidth * viewportScale;
            drawCurvedPath(cps, points);

            for (var i = 0; i < points.length / 2; i++) {
                if (hoveredPath != i) {
                    fillPath(i);
                }
            }

            fillPath(hoveredPath);

            const mousePositionInCanvas = toCanvasPosition(mousePosition[0] + 2 * viewport.x.from, mousePosition[1] + 2 * viewport.y.from, {
                mouse: true
            });

            if (selecting == true) {
                ctx.save();
                ctx.beginPath();
                ctx.fillStyle = 'rgba(26, 115, 232, .2)'
                ctx.strokeStyle = 'rgb(26, 115, 232)';
                ctx.lineWidth = .75;
                ctx.fillRect(selectRange.x[0], selectRange.y[0], selectRange.x[1] - selectRange.x[0], selectRange.y[1] - selectRange.y[0]);
                ctx.strokeRect(selectRange.x[0], selectRange.y[0], selectRange.x[1] - selectRange.x[0], selectRange.y[1] - selectRange.y[0]);
                ctx.closePath();
                ctx.restore();
            }

            ctx.save();
            ctx.textAlign = 'right';
            ctx.textBaseline = 'bottom';
            ctx.font = `14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif`
            ctx.fillText(`${mousePositionInCanvas.x}, ${mousePositionInCanvas.y} pixel(s)`, getCtxSize(ctx).width - 16, getCtxSize(ctx).height - 16)
            ctx.restore();

            if (showScaleInfo == true) {
                ctx.save();
                var translateY = getAnimateData(scaleInfoStatus == 'appearing' ? showScaleInfoKeyframes : hideScaleInfoKeyframes, 'translateY', Date.now() - scaleInfoTransitionStartTime, scaleInfoTransitionDuration);
                if (Date.now() - scaleInfoTransitionStartTime >= scaleInfoTransitionDuration) {
                    if (scaleInfoStatus == 'appearing') {
                        translateY = showScaleInfoKeyframes[100].translateY;
                    } else if (scaleInfoStatus == 'disappearing') {
                        translateY = hideScaleInfoKeyframes[100].translateY;
                    }
                }
                ctx.translate(0, translateY * 100);
                ctx.textBlock(`${(viewportScale * 100).toFixed(0)}%`, getCtxSize(ctx).width / 2, getCtxSize(ctx).height - (12 * 2 + 16 + 16), {
                    left: 16,
                    right: 16,
                    top: 12,
                    bottom: 12
                }, 6, {
                    fontSize: 16,
                    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif',
                    background: '#fff',
                    border: 'transparent',
                    align: 'center',
                    shadow: [0, 6, 24, 4, 'rgba(0, 0, 0, .08)']
                });
                ctx.restore();
            }

            // bzCurve(points, .2, 1);

            requestAnimationFrame(animate);
        }
        animate();

        //********** Scale Event *************//
        window.addEventListener('wheel', (e) => {
            if (e.ctrlKey) { // Check if Ctrl key is pressed (for zooming)
                showScaleInfo = true;
                showScaleInfoCount++;
                scaleInfoStatus = 'appearing';
                if (showScaleInfoCount == 1) {
                    scaleInfoTransitionStartTime = Date.now();
                }
                e.cancelable && e.preventDefault();
                const deltaY = e.deltaY;
                const deltaScale = deltaY < 0 ? 0.1 : -0.1; // Adjust scale factor based on deltaY
                viewportScale += deltaScale;
                viewportScale = Number(Math.max(0.1, Math.min(10, viewportScale)).toFixed(2)); // Limit scale factor to 0.1-10

                // console.log(`Scale factor: ${viewportScale}`, viewportScale);

                points = [...originalPoints];
                points.forEach((point, i) => {
                    points[i] = point * viewportScale - (i % 2 == 0 ? viewport.x.from : viewport.y.from);
                });

                size = defaultSize * viewportScale;
                diffusion = defaultDiffusion * viewportScale;
                setTimeout(() => {
                    if (showScaleInfoCount == 1) {
                        scaleInfoStatus = 'disappearing';
                        scaleInfoTransitionStartTime = Date.now();
                        setTimeout(() => {
                            if (showScaleInfoCount == 1) {
                                scaleInfoStatus = 'default';
                                showScaleInfo = false;
                            }
                            showScaleInfoCount--;
                        }, scaleInfoTransitionDuration)
                    } else {
                        showScaleInfoCount--;
                    }
                }, scaleInfoVisibleTime + scaleInfoTransitionDuration);
            }
        }, { passive: false });

        canvas.addEventListener('contextmenu', function (e) {
            originalPoints.push((e.pageX + viewport.x.from) / viewportScale);
            originalPoints.push((e.pageY + viewport.y.from) / viewportScale);
            points = [...originalPoints];
            points.forEach((point, i) => {
                points[i] = point * viewportScale - (i % 2 == 0 ? viewport.x.from : viewport.y.from);
            });
            e.preventDefault();
            return false;
        })

        var startPosition = {
            x: 0, y: 0
        }

        document.addEventListener('mousedown', (e) => {
            const position = toCanvasPosition(e.pageX, e.pageY, {
                convert: false
            });
            e.pageX = position.x;
            e.pageY = position.y;
            const index = inWhichPath(e.pageX, e.pageY);
            if (index > -1) {
                if (e.which == 1) {
                    if (e.ctrlKey == true && !selected.includes(index)) {
                        selected.push(index)
                    } else if (selected.length <= 1) {
                        selected = [index];
                    }
                }
                mousePosition = [e.pageX, e.pageY];
                mouseDown = true;
                canvas.style.cursor = 'grabbing';
            } else {
                selected = [];
                if (e.which == 1 && e.ctrlKey) {
                    selecting = true;
                    selectRange = {
                        x: [e.pageX, e.pageX],
                        y: [e.pageY, e.pageY]
                    }
                    canvas.style.cursor = 'crosshair';
                } else {
                    canvas.style.cursor = 'default';
                    if (e.which == 1) {
                        moving = true;
                    }
                }
            }
        })

        document.addEventListener('mousemove', (e) => {
            const position = toCanvasPosition(e.pageX, e.pageY, {
                convert: false
            });
            e.pageX = position.x;
            e.pageY = position.y;
            const index = inWhichPath(e.pageX, e.pageY);
            if (index > -1) {
                canvas.style.cursor = 'grab';
            } else {
                canvas.style.cursor = 'default';
            }
            hoveredPath = index;
            if (mouseDown == true) {
                canvas.style.cursor = 'grabbing';
                selected.forEach(selectedPath => {
                    originalPoints[selectedPath * 2] += (e.pageX - mousePosition[0]) / viewportScale;
                    originalPoints[selectedPath * 2 + 1] += (e.pageY - mousePosition[1]) / viewportScale;
                    points = [...originalPoints];
                    points.forEach((point, i) => {
                        points[i] = point * viewportScale - (i % 2 == 0 ? viewport.x.from : viewport.y.from);
                    });
                })
            }
            if (selecting == true) {
                canvas.style.cursor = 'crosshair';
                selectRange = {
                    x: [selectRange.x[0], e.pageX],
                    y: [selectRange.y[0], e.pageY]
                }
            }
            if (moving == true) {
                viewport.x.from -= e.pageX - mousePosition[0];
                viewport.x.to -= e.pageX - mousePosition[0];
                viewport.y.from -= e.pageY - mousePosition[1];
                viewport.y.to -= e.pageY - mousePosition[1];
            }
            mousePosition = [e.pageX, e.pageY];
        })

        document.addEventListener('mouseup', (e) => {
            const position = toCanvasPosition(e.pageX, e.pageY, {
                convert: false
            });
            e.pageX = position.x;
            e.pageY = position.y;
            if (mouseDown == true && e.ctrlKey == false) {
                selected = [];
            }
            mouseDown = false;
            selecting = false;
            moving = false;
            if (inWhichPath(e.pageX, e.pageY) > -1) {
                canvas.style.cursor = 'grab';
            } else {
                canvas.style.cursor = 'default';
            }
        })
    </script>
</body>

</html>